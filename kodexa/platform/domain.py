# generated by datamodel-codegen:
#   filename:  api-docs.yaml
#   timestamp: 2021-10-21T08:57:17+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, constr


class FavoriteLink(BaseModel):
    link: Optional[str] = None


class UserStorage(BaseModel):
    favoriteLinks: Optional[List[FavoriteLink]] = None


class CompletePasswordReset(BaseModel):
    resetToken: str
    password: str


class Organization(BaseModel):
    id: Optional[str] = Field(None, description='The unique ID of the document family')
    uuid: Optional[str] = None
    createdOn: Optional[datetime] = None
    updatedOn: Optional[datetime] = None
    createdBy: Optional[str] = None
    updatedBy: Optional[str] = None
    name: str
    slug: constr(regex=r'^[a-zA-Z0-9\-_]{0,40}$')
    publicAccess: Optional[bool] = None
    description: Optional[str] = None


class Team(BaseModel):
    id: Optional[str] = Field(None, description='The unique ID of the document family')
    uuid: Optional[str] = None
    createdOn: Optional[datetime] = None
    updatedOn: Optional[datetime] = None
    name: Optional[str] = None
    description: Optional[str] = None
    organization: Optional[Organization] = None


class TheCategoryOfAssistant(Enum):
    TASK = 'TASK'
    DOCUMENT = 'DOCUMENT'
    CONNECTOR = 'CONNECTOR'
    MACHINE_LEARNING = 'MACHINE_LEARNING'
    SUPPLEMENTAL = 'SUPPLEMENTAL'


class AssistantImplementation(BaseModel):
    package: Optional[str] = None
    class_: Optional[str] = Field(None, alias='class')


class AssistantSubscription(BaseModel):
    id: Optional[str] = None
    type: str = Field(..., description='The type of subscription object')


class AssistantTaxonomy(BaseModel):
    ref: Optional[str] = None


class Avatar(BaseModel):
    icon: Optional[str] = None
    iconGroup: Optional[str] = None


class ColumnState(BaseModel):
    field: Optional[str] = None
    title: Optional[str] = None
    cell: Optional[str] = None
    width: Optional[str] = None
    groupable: Optional[bool] = None
    sortable: Optional[bool] = None
    resizeable: Optional[bool] = None


class ContainerResources(BaseModel):
    memory: Optional[str] = None
    cpu: Optional[str] = None


class DashboardWidget(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None
    type: Optional[str] = None
    height: Optional[str] = None


class DeploymentType(Enum):
    KUBERNETES = 'KUBERNETES'
    AWS_LAMBDA = 'AWS_LAMBDA'
    AZURE_CLOUD_FUNCTION = 'AZURE_CLOUD_FUNCTION'
    NONE = 'NONE'


class DeploymentMetadata(BaseModel):
    deploymentType: Optional[DeploymentType] = None
    minReplicas: Optional[int] = None
    maxReplicas: Optional[int] = None
    reservedConcurrency: Optional[int] = None
    limits: Optional[ContainerResources] = None
    requests: Optional[ContainerResources] = None
    memoryAssigned: Optional[str] = None
    containerName: Optional[str] = None
    serviceName: Optional[str] = None
    functionArn: Optional[str] = None
    subscriptionArn: Optional[str] = None
    sentryDsn: Optional[str] = None
    queueUrl: Optional[str] = None
    eventSourceMappingUuid: Optional[str] = None
    environment: Optional[Dict[str, str]] = None
    matchLabels: Optional[Dict[str, str]] = None


class DocumentColumn(BaseModel):
    label: Optional[str] = Field(
        None, description='The label to use for the column heading'
    )
    path: Optional[str] = Field(None, description='The path to the data')


class EventFilter(BaseModel):
    eventType: Optional[str] = None
    path: Optional[str] = None
    caseSensitive: Optional[bool] = None


class EventType(BaseModel):
    name: Optional[str] = None
    icon: Optional[str] = None
    label: Optional[str] = None
    contentObject: Optional[bool] = None


class Status(Enum):
    PENDING = 'PENDING'
    BUILDING = 'BUILDING'
    BUILT = 'BUILT'
    AVAILABLE = 'AVAILABLE'
    FAILED = 'FAILED'
    UNDEPLOYED = 'UNDEPLOYED'


class ExtensionPackSource(BaseModel):
    type: Optional[str] = None


class LabelSubscription(AssistantSubscription):
    labels: Optional[List[str]] = None
    inverted: Optional[bool] = None


class MetadataTag(BaseModel):
    tag: Optional[str] = None
    imageUrl: Optional[str] = None


class MixinSubscription(AssistantSubscription):
    mixins: Optional[List[str]] = None
    inverted: Optional[bool] = None


class DeploymentType1(Enum):
    LOCAL = 'LOCAL'
    CONTAINER = 'CONTAINER'


class PathSubscription(AssistantSubscription):
    path: Optional[str] = None
    caseSensitive: Optional[bool] = None
    inverted: Optional[bool] = None


class PipelineExample(BaseModel):
    title: Optional[str] = Field(None, description='Title of the example')
    description: Optional[str] = Field(None, description='Description of the example')
    url: Optional[str] = Field(None, description='URL to the example input')


class PipelineStepMetadata(BaseModel):
    name: Optional[str] = Field(None, description='The name of the step')
    ref: Optional[str] = Field(None, description='The reference to the action')
    enabled: Optional[bool] = Field(None, description='The reference to the action')
    conditional: Optional[bool] = Field(None, description='Is the step conditional')
    condition: Optional[str] = Field(None, description='The condition for the step')
    parameterized: Optional[bool] = Field(None, description='Is the step parameterized')
    options: Optional[Dict[str, Dict[str, Any]]] = None


class StoreType(Enum):
    DOCUMENT = 'DOCUMENT'
    TABLE = 'TABLE'
    DICTIONARY = 'DICTIONARY'
    MODEL = 'MODEL'


class PipelineStore(BaseModel):
    name: Optional[str] = None
    ref: Optional[str] = None
    storeType: Optional[StoreType] = None


class PossibleValue(BaseModel):
    label: Optional[str] = None
    value: Optional[Dict[str, Any]] = None


class StoreType1(Enum):
    DOCUMENT = 'DOCUMENT'
    TABLE = 'TABLE'
    DICTIONARY = 'DICTIONARY'
    MODEL = 'MODEL'


class StorePurpose(Enum):
    OPERATIONAL = 'OPERATIONAL'
    TRAINING = 'TRAINING'


class ProjectStore(BaseModel):
    slug: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None
    storeType: Optional[StoreType1] = None
    storePurpose: Optional[StorePurpose] = None


class TaxonomyType(Enum):
    CONTENT = 'CONTENT'
    CLASSIFICATION = 'CLASSIFICATION'
    PROCESSING = 'PROCESSING'


class TheCategoryOfProjectTemplate(Enum):
    TASK = 'TASK'
    DOCUMENT = 'DOCUMENT'
    CONNECTOR = 'CONNECTOR'
    MACHINE_LEARNING = 'MACHINE_LEARNING'
    SUPPLEMENTAL = 'SUPPLEMENTAL'


class ScheduleDefinition(BaseModel):
    type: Optional[str] = None
    cronExpression: Optional[str] = None
    lastEvent: Optional[datetime] = None
    nextEvent: Optional[datetime] = None


class SelectionOption(BaseModel):
    label: Optional[str] = None
    value: Optional[Dict[str, Any]] = None
    description: Optional[str] = None


class SlugBasedMetadata(BaseModel):
    ref: Optional[str] = Field(None, description='The reference to the metadata object')
    schemaVersion: Optional[int] = Field(None, description='The version of the schema')
    orgSlug: Optional[constr(regex=r'^[a-zA-Z0-9\-_]{0,255}$')] = Field(
        None, description='The slug of the organization that owns this metadata object'
    )
    slug: constr(regex=r'^[a-zA-Z0-9\-_]{0,40}$') = Field(
        ..., description='The slug used when referencing this metadata object'
    )
    type: str = Field(..., description='The type of metadata object')
    name: str = Field(..., description='The name of the object')
    description: Optional[str] = Field(
        None, description='The description of the object'
    )
    version: Optional[str] = Field(None, description='The version of the object')
    deployed: Optional[datetime] = Field(
        None,
        description='The date/time the object was deployed into this Kodexa instance',
    )
    publicAccess: Optional[bool] = Field(
        None,
        description='Is the metadata object publicly accessible by other organizations',
    )
    URL_of_image_for_assistant: Optional[str] = Field(
        None, alias='URL of image for assistant'
    )
    A_list_of_associated_tags: Optional[List[MetadataTag]] = Field(
        None, alias='A list of associated tags'
    )


class StepImplementation(BaseModel):
    package: Optional[str] = None
    class_: Optional[str] = Field(None, alias='class')


class StoreType2(Enum):
    DOCUMENT = 'DOCUMENT'
    TABLE = 'TABLE'
    DICTIONARY = 'DICTIONARY'
    MODEL = 'MODEL'


class StorePurpose1(Enum):
    OPERATIONAL = 'OPERATIONAL'
    TRAINING = 'TRAINING'


class StoreFilter(BaseModel):
    pass


class StoreViewOptions(BaseModel):
    showLastEvent: Optional[bool] = None
    showExtension: Optional[bool] = None
    showCreated: Optional[bool] = None
    showModified: Optional[bool] = None
    showPathCounts: Optional[bool] = None
    showClassifications: Optional[bool] = None
    showSize: Optional[bool] = None
    showAssignments: Optional[bool] = None
    showStatus: Optional[bool] = None
    additionalColumns: Optional[List[DocumentColumn]] = None
    columnStates: Optional[Dict[str, List[ColumnState]]] = None


class TabGroup(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None
    icon: Optional[str] = None
    showIf: Optional[str] = None


class ValuePath(Enum):
    VALUE_OR_ALL_CONTENT = 'VALUE_OR_ALL_CONTENT'
    VALUE_ONLY = 'VALUE_ONLY'
    ALL_CONTENT = 'ALL_CONTENT'
    DATA_PATH = 'DATA_PATH'
    METADATA = 'METADATA'
    EXPRESSION = 'EXPRESSION'


class MetadataValue(Enum):
    FILENAME = 'FILENAME'
    TRANSACTION_UUID = 'TRANSACTION_UUID'
    CREATED_DATETIME = 'CREATED_DATETIME'


class TaxonType(Enum):
    STRING = 'STRING'
    DATE = 'DATE'
    DATE_TIME = 'DATE_TIME'
    NUMBER = 'NUMBER'
    DECIMAL = 'DECIMAL'
    FLOAT = 'FLOAT'
    BOOLEAN = 'BOOLEAN'
    CURRENCY = 'CURRENCY'
    URL = 'URL'
    EMAIL_ADDRESS = 'EMAIL_ADDRESS'
    PHONE_NUMBER = 'PHONE_NUMBER'
    POSTAL_CODE = 'POSTAL_CODE'
    SELECTION = 'SELECTION'


class TaxonomyType1(Enum):
    CONTENT = 'CONTENT'
    CLASSIFICATION = 'CLASSIFICATION'
    PROCESSING = 'PROCESSING'


class TextboxWidget(DashboardWidget):
    title: Optional[str] = None
    subtitle: Optional[str] = None
    body: Optional[str] = None


class ReprocessRequest(BaseModel):
    assistantIds: Optional[List[str]] = None
    familyIds: Optional[List[str]] = None


class ContentMetadata(BaseModel):
    type: Optional[str] = None


class DocumentContentMetadata(ContentMetadata):
    type: Optional[str] = Field(None, description='The type of content metadata')


class State(Enum):
    PENDING = 'PENDING'
    PREPARING = 'PREPARING'
    PREPARED = 'PREPARED'
    TRAINING = 'TRAINING'
    TRAINED = 'TRAINED'
    AVAILABLE = 'AVAILABLE'
    FAILED = 'FAILED'


class ModelContentMetadata(ContentMetadata):
    type: Optional[str] = Field(None, description='The type of content metadata')
    modelRuntimeRef: Optional[str] = Field(
        None, description='The reference to the model runtime to use'
    )
    state: Optional[State] = Field(
        None, description='The state of the model in this store'
    )
    parameters: Optional[Dict[str, Dict[str, Any]]] = Field(
        None, description='The parameters passed to this model instance'
    )
    buildStatistics: Optional[Dict[str, Dict[str, Any]]] = Field(
        None,
        description='Build statistics (note this will update if the model is training)',
    )
    finalStatistics: Optional[Dict[str, Dict[str, Any]]] = Field(
        None, description='Final statistics from the model'
    )
    deployment: Optional[Dict[str, Dict[str, Any]]] = Field(
        None, description='Details of the model deployment (if available)'
    )


class ContentClassification(BaseModel):
    label: Optional[str] = None
    taxonomy: Optional[str] = None
    selector: Optional[str] = None
    confidence: Optional[float] = None


class ContentType(Enum):
    DOCUMENT = 'DOCUMENT'
    NATIVE = 'NATIVE'


class ActorType(Enum):
    USER = 'USER'
    ASSISTANT = 'ASSISTANT'
    ACCESS_TOKEN = 'ACCESS_TOKEN'
    API = 'API'


class DocumentActor(BaseModel):
    actorId: Optional[str] = Field(
        None, description='The ID for the actor (dependent on the actor type)'
    )
    actorType: Optional[ActorType] = Field(None, description='The type of actor')


class StatusType(Enum):
    UNRESOLVED = 'UNRESOLVED'
    RESOLVED = 'RESOLVED'


class DocumentStatus(BaseModel):
    id: Optional[str] = Field(None, description='The unique ID of the document family')
    uuid: Optional[str] = None
    createdOn: Optional[datetime] = None
    updatedOn: Optional[datetime] = None
    color: Optional[str] = None
    icon: Optional[str] = None
    status: str
    statusType: Optional[StatusType] = None


class TransitionType(Enum):
    DERIVED = 'DERIVED'


class DocumentTransition(BaseModel):
    id: Optional[str] = Field(None, description='The unique ID of the document family')
    uuid: Optional[str] = None
    createdOn: Optional[datetime] = None
    updatedOn: Optional[datetime] = None
    transitionType: Optional[TransitionType] = Field(
        None, description='The type of transition'
    )
    index: Optional[int] = None
    dateTime: Optional[datetime] = Field(
        None, description='The date/time of the transition'
    )
    actor: Optional[DocumentActor] = None
    label: Optional[str] = Field(
        None,
        description='A label for the transition (this can be used later if we want to prune based on a label)',
    )
    sourceContentObjectId: Optional[str] = None
    destinationContentObjectId: Optional[str] = None


class Label(BaseModel):
    id: Optional[str] = Field(None, description='The unique ID of the document family')
    uuid: Optional[str] = None
    createdOn: Optional[datetime] = None
    updatedOn: Optional[datetime] = None
    color: Optional[str] = None
    label: str
    name: str


class SourceMetadata(BaseModel):
    checksum: Optional[str] = None
    created: Optional[str] = None
    connector: Optional[str] = None
    cid: Optional[str] = None
    headers: Optional[Dict[str, Dict[str, Any]]] = None
    original_filename: Optional[str] = None
    original_path: Optional[str] = None
    last_modified: Optional[str] = None
    mime_type: Optional[str] = None
    lineage_document_uuid: Optional[str] = None
    document_family_id: Optional[str] = None
    source_document_uuid: Optional[str] = None


class BulkCopy(BaseModel):
    targetStoreRef: Optional[str] = None
    documentFamilyIds: Optional[List[str]] = None


class ContentFeature(BaseModel):
    featureType: Optional[str] = None
    name: Optional[str] = None
    value: Optional[List[Dict[str, Any]]] = None
    single: Optional[bool] = None


class NodeFeatures(BaseModel):
    nodeUuid: Optional[str] = None
    features: Optional[List[ContentFeature]] = None


class StatusType1(Enum):
    UNRESOLVED = 'UNRESOLVED'
    RESOLVED = 'RESOLVED'


class AttributeStatus(BaseModel):
    id: Optional[str] = Field(None, description='The unique ID of the document family')
    uuid: Optional[str] = None
    createdOn: Optional[datetime] = None
    updatedOn: Optional[datetime] = None
    color: Optional[str] = None
    icon: Optional[str] = None
    status: Optional[str] = None
    statusType: Optional[StatusType1] = None


class CellValidationMessage(BaseModel):
    message: Optional[str] = Field(
        None, description='Message to describe the validation issue'
    )
    validationFeatures: Optional[Dict[str, Dict[str, Any]]] = Field(
        None, description='Additional features from the validation'
    )


class DataType(Enum):
    STRING = 'STRING'
    DATE = 'DATE'
    DATE_TIME = 'DATE_TIME'
    NUMBER = 'NUMBER'
    DECIMAL = 'DECIMAL'
    FLOAT = 'FLOAT'
    BOOLEAN = 'BOOLEAN'
    CURRENCY = 'CURRENCY'
    URL = 'URL'
    EMAIL_ADDRESS = 'EMAIL_ADDRESS'
    PHONE_NUMBER = 'PHONE_NUMBER'
    POSTAL_CODE = 'POSTAL_CODE'
    SELECTION = 'SELECTION'


class ValidationState(Enum):
    VALID = 'VALID'
    INVALID = 'INVALID'
    WARNING = 'WARNING'


class DataAttribute(BaseModel):
    id: Optional[str] = Field(None, description='The unique ID of the document family')
    uuid: Optional[str] = None
    createdOn: Optional[datetime] = None
    updatedOn: Optional[datetime] = None
    value: Optional[str] = None
    truncated: Optional[bool] = None
    dataType: DataType
    tag: str
    tagUuid: Optional[str] = None
    dateValue: Optional[datetime] = None
    floatValue: Optional[float] = None
    decimalValue: Optional[float] = None
    numberValue: Optional[int] = None
    booleanValue: Optional[bool] = None
    stringValue: Optional[str] = None
    attributeStatus: Optional[AttributeStatus] = None
    validationState: ValidationState = Field(
        ..., description='The current validation state'
    )
    validationMessages: Optional[List[CellValidationMessage]] = Field(
        None, description='A list of messages relating to the validity'
    )
    dataFeatures: Optional[Dict[str, Dict[str, Any]]] = Field(
        None, description='Additional features for the data'
    )
    label: Optional[str] = None


class DataLineage(BaseModel):
    storeRef: Optional[str] = None
    documentFamilyId: Optional[str] = None
    executionId: Optional[str] = None
    contentObjectId: Optional[str] = None


class AssistantSchedule(BaseModel):
    type: Optional[str] = None
    cronExpression: Optional[str] = None
    lastEvent: Optional[datetime] = None
    nextEvent: Optional[datetime] = None
    id: Optional[str] = None


class ValidationError(BaseModel):
    id: Optional[str] = Field(None, description='The unique ID of the document family')
    uuid: Optional[str] = None
    createdOn: Optional[datetime] = None
    updatedOn: Optional[datetime] = None
    message: Optional[str] = None
    option: Optional[str] = None
    description: Optional[str] = None


class Role1(Enum):
    OWNER = 'OWNER'
    READ = 'READ'
    WRITE = 'WRITE'


class DeploymentType2(Enum):
    KUBERNETES = 'KUBERNETES'
    AWS_LAMBDA = 'AWS_LAMBDA'
    AZURE_CLOUD_FUNCTION = 'AZURE_CLOUD_FUNCTION'
    NONE = 'NONE'


class DeploymentOptions(BaseModel):
    deploymentType: Optional[DeploymentType2] = None
    maxReplicas: Optional[int] = None
    minReplicas: Optional[int] = None
    reservedConcurrency: Optional[int] = None
    memoryAssigned: Optional[str] = None
    cpu: Optional[str] = None
    sentryDsn: Optional[str] = None


class PlatformConfiguration(BaseModel):
    id: Optional[str] = Field(None, description='The unique ID of the document family')
    uuid: Optional[str] = None
    createdOn: Optional[datetime] = None
    updatedOn: Optional[datetime] = None
    createdBy: Optional[str] = None
    updatedBy: Optional[str] = None
    welcomeMarkdown: Optional[str] = None
    aboutMarkdown: Optional[str] = None
    loginMessage: Optional[str] = None
    baseOrgSlug: Optional[str] = None
    title: Optional[str] = None
    organizationTitle: Optional[str] = None
    organizationsTitle: Optional[str] = None
    organizationDescription: Optional[str] = None
    projectTitle: Optional[str] = None
    projectsTitle: Optional[str] = None
    projectDescription: Optional[str] = None
    developerLinks: Optional[bool] = None
    allowRegistration: Optional[bool] = None
    allowPasswordReset: Optional[bool] = None
    extensionPackBridge: Optional[str] = None


class UserActivation(BaseModel):
    firstName: Optional[str] = None
    lastName: Optional[str] = None
    password: Optional[str] = None


class AccessToken(BaseModel):
    id: Optional[str] = Field(None, description='The unique ID of the document family')
    uuid: Optional[str] = None
    createdOn: Optional[datetime] = None
    updatedOn: Optional[datetime] = None
    createdBy: Optional[str] = None
    updatedBy: Optional[str] = None
    name: str
    token: Optional[str] = None
    organization: Optional[Organization] = None


class SearchEntity(BaseModel):
    entity: Optional[str] = Field(None, description='The type of entity')
    value: Optional[str] = Field(None, description='The entity value')
    start: Optional[int] = Field(None, description='Start position')
    end: Optional[int] = Field(None, description='End position')


class StoreType3(Enum):
    DOCUMENT = 'DOCUMENT'
    TABLE = 'TABLE'
    DICTIONARY = 'DICTIONARY'
    MODEL = 'MODEL'


class SessionStore(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None
    storeType: Optional[StoreType3] = None
    ref: Optional[str] = None
    data: Optional[Dict[str, Dict[str, Any]]] = None


class DeploymentType3(Enum):
    KUBERNETES = 'KUBERNETES'
    AWS_LAMBDA = 'AWS_LAMBDA'
    AZURE_CLOUD_FUNCTION = 'AZURE_CLOUD_FUNCTION'
    NONE = 'NONE'


class Status1(Enum):
    PENDING = 'PENDING'
    RUNNING = 'RUNNING'
    SUCCEEDED = 'SUCCEEDED'
    FAILED = 'FAILED'
    REQUESTED = 'REQUESTED'
    SKIPPED = 'SKIPPED'


class ExceptionDetails(BaseModel):
    message: Optional[str] = None
    statusCode: Optional[int] = None
    errorMessage: Optional[str] = None
    errorType: Optional[str] = None
    executedVersion: Optional[str] = None
    advice: Optional[str] = None
    description: Optional[str] = None
    cause: Optional[Dict[str, Any]] = None
    documentationUrl: Optional[str] = None
    stackTrace: Optional[List[Dict[str, Any]]] = None
    help: Optional[str] = None
    optionErrors: Optional[Dict[str, Dict[str, Any]]] = None
    validationErrors: Optional[List[ValidationError]] = None


class Status2(Enum):
    PENDING = 'PENDING'
    RUNNING = 'RUNNING'
    SUCCEEDED = 'SUCCEEDED'
    FAILED = 'FAILED'
    REQUESTED = 'REQUESTED'
    SKIPPED = 'SKIPPED'


class DeploymentType4(Enum):
    KUBERNETES = 'KUBERNETES'
    AWS_LAMBDA = 'AWS_LAMBDA'
    AZURE_CLOUD_FUNCTION = 'AZURE_CLOUD_FUNCTION'
    NONE = 'NONE'


class Type(Enum):
    START_EXECUTION = 'START_EXECUTION'
    STEP_UPDATE = 'STEP_UPDATE'
    ASSISTANT_EVENT = 'ASSISTANT_EVENT'
    ASSISTANT_RESPONSE = 'ASSISTANT_RESPONSE'
    MODEL_TRAIN = 'MODEL_TRAIN'
    MODEL_INFER = 'MODEL_INFER'


class TargetDeploymentType(Enum):
    KUBERNETES = 'KUBERNETES'
    AWS_LAMBDA = 'AWS_LAMBDA'
    AZURE_CLOUD_FUNCTION = 'AZURE_CLOUD_FUNCTION'
    NONE = 'NONE'


class Status3(Enum):
    PENDING = 'PENDING'
    RUNNING = 'RUNNING'
    SUCCEEDED = 'SUCCEEDED'
    FAILED = 'FAILED'
    REQUESTED = 'REQUESTED'
    SKIPPED = 'SKIPPED'


class Type1(Enum):
    DOCUMENT_STORE = 'DOCUMENT_STORE'
    TAXONOMY_STORE = 'TAXONOMY_STORE'
    DATA_STORE = 'DATA_STORE'


class ExecutionTarget(BaseModel):
    type: Optional[Type1] = None
    ref: Optional[str] = None
    documentFamilyId: Optional[str] = None
    contentObjectId: Optional[str] = None
    actor: Optional[DocumentActor] = None
    taxonomyRefs: Optional[List[str]] = None


class State1(Enum):
    OPEN = 'OPEN'
    CLOSED = 'CLOSED'


class Session(BaseModel):
    id: Optional[str] = Field(None, description='The unique ID of the document family')
    uuid: Optional[str] = None
    createdOn: Optional[datetime] = None
    updatedOn: Optional[datetime] = None
    state: State1
    token: Optional[str] = None
    organization: Optional[Organization] = None
    lastAccessed: Optional[datetime] = None


class ExecutionLogEntry(BaseModel):
    id: Optional[str] = Field(None, description='The unique ID of the document family')
    uuid: Optional[str] = None
    createdOn: Optional[datetime] = None
    updatedOn: Optional[datetime] = None
    entry: Optional[str] = None


class LoginRequest(BaseModel):
    email: str
    password: str


class RegisterUser(BaseModel):
    email: str
    firstName: str
    lastName: str


class PasswordReset(BaseModel):
    email: str


class PasswordChange(BaseModel):
    oldPassword: str
    newPassword: str


class PlatformOverview(BaseModel):
    name: Optional[str] = None
    release: Optional[str] = None
    description: Optional[str] = None
    hostName: Optional[str] = Field(None, description='The hostname for this instance')
    environment: Optional[str] = Field(
        None,
        description='The name of the environment in which this instance is running',
    )
    commitId: Optional[str] = Field(
        None, description='The git commit ID for this API server instance running'
    )
    buildTime: Optional[str] = Field(
        None, description='The build time for this API server instance running'
    )
    version: Optional[str] = Field(
        None, description='The version of API server instance running'
    )
    ua: Optional[str] = Field(None, description='Google UA')
    dsn: Optional[str] = None


class QueryContext(BaseModel):
    Page_size__default_20_: Optional[int] = Field(None, alias='Page size (default 20)')
    Page_number__default_1_: Optional[int] = Field(
        None, alias='Page number (default 1)'
    )
    Sorts_to_apply: Optional[str] = Field(None, alias='Sorts to apply')
    Simple_filter_to_apply: Optional[str] = Field(None, alias='Simple filter to apply')
    Simple_query_to_apply__if_available_: Optional[str] = Field(
        None, alias='Simple query to apply (if available)'
    )


class Sort(BaseModel):
    empty: Optional[bool] = None
    sorted: Optional[bool] = None
    unsorted: Optional[bool] = None


class Status4(Enum):
    PENDING = 'PENDING'
    RUNNING = 'RUNNING'
    SUCCEEDED = 'SUCCEEDED'
    FAILED = 'FAILED'
    REQUESTED = 'REQUESTED'
    SKIPPED = 'SKIPPED'


class AccessTokenDetails(BaseModel):
    type: Optional[str] = None
    token: Optional[str] = None
    organizationSlugs: Optional[List[str]] = None
    orgSlug: Optional[str] = None


class BulkDelete(BaseModel):
    documentFamilyIds: Optional[List[str]] = None


class User(BaseModel):
    id: Optional[str] = Field(None, description='The unique ID of the document family')
    uuid: Optional[str] = None
    createdOn: Optional[datetime] = None
    updatedOn: Optional[datetime] = None
    createdBy: Optional[str] = None
    updatedBy: Optional[str] = None
    email: str
    firstName: str
    lastName: str
    activated: Optional[bool] = None
    platformAdmin: Optional[bool] = None
    passwordResetDate: Optional[datetime] = None
    lastConnected: Optional[datetime] = None
    userStorage: Optional[UserStorage] = None


class ChartWidget(DashboardWidget):
    options: Optional[Dict[str, Dict[str, Any]]] = None


class Credential(SlugBasedMetadata):
    extensionPackRef: Optional[str] = Field(
        None,
        description='The reference to the extension pack (if the metadata object was created by an extension pack)',
    )


class DashboardColumn(BaseModel):
    id: Optional[str] = None
    cols: Optional[str] = None
    height: Optional[str] = None
    widgets: Optional[List[DashboardWidget]] = None


class DashboardRow(BaseModel):
    id: Optional[str] = None
    height: Optional[str] = None
    columns: Optional[List[DashboardColumn]] = None


class DockerSource(ExtensionPackSource):
    location: Optional[str] = None


class ExtensionPack(SlugBasedMetadata):
    orgSlug: Optional[constr(regex=r'^[a-zA-Z0-9\-_]{0,40}$')] = None
    slug: Optional[constr(regex=r'^[a-zA-Z0-9\-_]{0,40}$')] = None
    name: Optional[str] = None
    description: Optional[str] = None
    publicAccess: Optional[bool] = None
    packUri: Optional[str] = None
    status: Optional[Status] = None
    services: Optional[List[SlugBasedMetadata]] = None
    source: Optional[ExtensionPackSource] = None
    deployment: Optional[DeploymentMetadata] = None


class ModelRuntime(SlugBasedMetadata):
    extensionPackRef: Optional[str] = Field(
        None,
        description='The reference to the extension pack (if the metadata object was created by an extension pack)',
    )
    inferenceStep: Optional[str] = None
    trainingEntrypoint: Optional[str] = None
    deploymentType: Optional[DeploymentType1] = None
    containerUrl: Optional[str] = None
    deployment: Optional[DeploymentMetadata] = None


class Option(BaseModel):
    tabId: Optional[str] = None
    name: Optional[str] = None
    label: Optional[str] = None
    hint: Optional[str] = None
    required: Optional[bool] = None
    type: Optional[str] = None
    listType: Optional[str] = None
    default: Optional[Dict[str, Any]] = None
    description: Optional[str] = None
    showIf: Optional[str] = None
    possibleValues: Optional[List[PossibleValue]] = None


class PipelineImplementationMetadata(BaseModel):
    steps: Optional[List[PipelineStepMetadata]] = Field(
        None, description='The metadata for the steps in this pipeline'
    )
    stores: Optional[List[PipelineStore]] = Field(
        None, description='The metadata for the stores in this pipeline'
    )
    moreInfoUrl: Optional[str] = Field(
        None, description='A URL for more information for this pipeline'
    )
    exampleUrls: Optional[List[PipelineExample]] = Field(
        None,
        description='A list of the examples of this pipeline, the examples are example inputs for the pipeline',
    )


class ProjectAssistant(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    assistantDefinitionRef: Optional[str] = None
    options: Optional[Dict[str, Dict[str, Any]]] = None
    stores: Optional[List[str]] = None
    schedules: Optional[List[ScheduleDefinition]] = None
    subscriptions: Optional[List[AssistantSubscription]] = None


class ProjectDashboard(BaseModel):
    slug: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None
    rows: Optional[List[DashboardRow]] = None


class SavedFilter(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None
    filter: Optional[StoreFilter] = None


class Store(SlugBasedMetadata):
    extensionPackRef: Optional[str] = Field(
        None,
        description='The reference to the extension pack (if the metadata object was created by an extension pack)',
    )
    storeType: Optional[StoreType2] = Field(
        None, description='The type of object the store will contain'
    )
    searchable: Optional[bool] = Field(
        None, description='Is the store indexed, and thus searchable'
    )
    storePurpose: Optional[StorePurpose1] = Field(
        None,
        description='The purpose of the store (used by UI and assistants to understand how to interact with the store events)',
    )
    viewOptions: Optional[StoreViewOptions] = None
    savedFilters: Optional[List[SavedFilter]] = Field(
        None, description='Filters that have been saved for this store'
    )


class Taxon(BaseModel):
    id: Optional[str] = Field(None, description='The ID of the taxon')
    label: Optional[str] = Field(None, description='The text to display for this taxon')
    generateName: Optional[bool] = Field(
        None,
        description='Is the name generated, this allows that you can change displays without impacted existing content',
    )
    group: Optional[bool] = Field(
        None,
        description="Is this taxon a group, and therefore can't have a value, can only have children",
    )
    name: Optional[constr(regex=r'^[a-zA-Z0-9\-_]{0,40}$')] = Field(
        None,
        description='The name to be used, note based on the hierarchy the actual label in the document will have the parent name too',
    )
    valuePath: Optional[ValuePath] = Field(
        None, description='Where to get the value for this taxon when extracting'
    )
    metadataValue: Optional[MetadataValue] = Field(
        None, description='If the type is metadata this will be the metadata option'
    )
    dataPath: Optional[str] = Field(
        None,
        description='The path to the data, based on the data inside the label (tag) within the document',
    )
    expression: Optional[str] = Field(
        None,
        description='If the taxon is based on expression, this is the expression based on the available objects',
    )
    description: Optional[str] = Field(None, description='The description of the taxon')
    enabled: Optional[bool] = Field(
        None, description='Is the taxon enabled (used in the UI)'
    )
    color: Optional[str] = Field(
        None, description='Hex encoding of the color to use for the taxon'
    )
    children: Optional[List[Taxon]] = Field(
        None, description='The children under this taxon'
    )
    options: Optional[List[Option]] = Field(
        None,
        description='Options that can be shown for the taxon (usually used in assistant taxonomies)',
    )
    nodeTypes: Optional[List[str]] = Field(
        None,
        description='A list of the node types that this taxon applies to (empty means everything), used in the UI',
    )
    taxonType: Optional[TaxonType] = Field(
        None, description='Expected data type to coalesce to (defaults to STRING)'
    )
    selectionOptions: Optional[List[SelectionOption]] = Field(
        None,
        description='If data type is SELECTION, this is the list of available options',
    )
    typeFeatures: Optional[Dict[str, Dict[str, Any]]] = Field(
        None, description='Additional features for the type handling'
    )
    path: Optional[str] = Field(None, description='The path to the node')


class Taxonomy(SlugBasedMetadata):
    type: Optional[str] = Field(None, description='The metadata object type')
    extensionPackRef: Optional[str] = Field(
        None,
        description='The reference to the extension pack (if the metadata object was created by an extension pack)',
    )
    taxonomyType: Optional[TaxonomyType1] = Field(
        None, description='The type of taxonomy'
    )
    enabled: Optional[bool] = Field(
        None, description='Is the taxonomy enabled (effects display in the UI)'
    )
    taxons: Optional[List[Taxon]] = Field(
        None, description="The hierarchical structure of taxon's in this taxonomy"
    )
    totalTaxons: Optional[int] = Field(
        None, description='The total number of taxons in the taxonomy'
    )


class ContentObject(BaseModel):
    id: Optional[str] = Field(None, description='The unique ID of the document family')
    uuid: Optional[str] = None
    createdOn: Optional[datetime] = None
    updatedOn: Optional[datetime] = None
    documentVersion: Optional[str] = None
    index: Optional[int] = None
    status: Optional[DocumentStatus] = None
    labels: Optional[List[Label]] = None
    metadata: Optional[Dict[str, Dict[str, Any]]] = None
    source: Optional[SourceMetadata] = None
    mixins: Optional[List[str]] = None
    contentMetadata: Optional[Dict[str, Dict[str, Any]]] = None
    created: Optional[datetime] = None
    modified: Optional[datetime] = None
    size: Optional[int] = None
    createdDate: Optional[datetime] = None
    modifiedDate: Optional[datetime] = None
    content_type: ContentType
    store_ref: Optional[str] = None
    documentFamilyId: Optional[str] = None


class FeatureSet(BaseModel):
    nodeFeatures: Optional[List[NodeFeatures]] = None


class Role(BaseModel):
    id: Optional[str] = Field(None, description='The unique ID of the document family')
    uuid: Optional[str] = None
    createdOn: Optional[datetime] = None
    updatedOn: Optional[datetime] = None
    createdBy: Optional[str] = None
    updatedBy: Optional[str] = None
    name: str
    users: Optional[List[User]] = None
    teams: Optional[List[Team]] = None


class Membership(BaseModel):
    id: Optional[str] = Field(None, description='The unique ID of the document family')
    uuid: Optional[str] = None
    createdOn: Optional[datetime] = None
    updatedOn: Optional[datetime] = None
    createdBy: Optional[str] = None
    updatedBy: Optional[str] = None
    role: Optional[Role1] = None
    organization: Optional[Organization] = None
    user: Optional[User] = None


class ExecutionStep(BaseModel):
    id: Optional[str] = None
    status: Optional[Status2] = None
    exceptionDetails: Optional[ExceptionDetails] = None
    name: Optional[str] = None
    start: Optional[datetime] = None
    end: Optional[datetime] = None
    processingTime: Optional[int] = None
    parameterized: Optional[bool] = None
    enabled: Optional[bool] = None
    options: Optional[Dict[str, Dict[str, Any]]] = None
    optionTypes: Optional[Dict[str, str]] = None
    context: Optional[Dict[str, Dict[str, Any]]] = None
    contentObjects: Optional[List[ContentObject]] = None
    stores: Optional[List[SessionStore]] = None
    inputId: Optional[str] = None
    outputId: Optional[str] = None
    ref: Optional[str] = None
    deploymentType: Optional[DeploymentType4] = None
    serviceName: Optional[str] = None
    containerName: Optional[str] = None


class Pageable(BaseModel):
    offset: Optional[int] = None
    sort: Optional[Sort] = None
    pageNumber: Optional[int] = None
    pageSize: Optional[int] = None
    paged: Optional[bool] = None
    unpaged: Optional[bool] = None


class PageTeam(BaseModel):
    totalElements: Optional[int] = None
    totalPages: Optional[int] = None
    size: Optional[int] = None
    content: Optional[List[Team]] = None
    number: Optional[int] = None
    sort: Optional[Sort] = None
    numberOfElements: Optional[int] = None
    pageable: Optional[Pageable] = None
    first: Optional[bool] = None
    last: Optional[bool] = None
    empty: Optional[bool] = None


class PageTaxonomy(BaseModel):
    totalElements: Optional[int] = None
    totalPages: Optional[int] = None
    size: Optional[int] = None
    content: Optional[List[Taxonomy]] = None
    number: Optional[int] = None
    sort: Optional[Sort] = None
    numberOfElements: Optional[int] = None
    pageable: Optional[Pageable] = None
    first: Optional[bool] = None
    last: Optional[bool] = None
    empty: Optional[bool] = None


class PageStore(BaseModel):
    totalElements: Optional[int] = None
    totalPages: Optional[int] = None
    size: Optional[int] = None
    content: Optional[List[Store]] = None
    number: Optional[int] = None
    sort: Optional[Sort] = None
    numberOfElements: Optional[int] = None
    pageable: Optional[Pageable] = None
    first: Optional[bool] = None
    last: Optional[bool] = None
    empty: Optional[bool] = None


class PageSession(BaseModel):
    totalElements: Optional[int] = None
    totalPages: Optional[int] = None
    size: Optional[int] = None
    content: Optional[List[Session]] = None
    number: Optional[int] = None
    sort: Optional[Sort] = None
    numberOfElements: Optional[int] = None
    pageable: Optional[Pageable] = None
    first: Optional[bool] = None
    last: Optional[bool] = None
    empty: Optional[bool] = None


class PageRole(BaseModel):
    totalElements: Optional[int] = None
    totalPages: Optional[int] = None
    size: Optional[int] = None
    content: Optional[List[Role]] = None
    number: Optional[int] = None
    sort: Optional[Sort] = None
    numberOfElements: Optional[int] = None
    pageable: Optional[Pageable] = None
    first: Optional[bool] = None
    last: Optional[bool] = None
    empty: Optional[bool] = None


class PageOrganization(BaseModel):
    totalElements: Optional[int] = None
    totalPages: Optional[int] = None
    size: Optional[int] = None
    content: Optional[List[Organization]] = None
    number: Optional[int] = None
    sort: Optional[Sort] = None
    numberOfElements: Optional[int] = None
    pageable: Optional[Pageable] = None
    first: Optional[bool] = None
    last: Optional[bool] = None
    empty: Optional[bool] = None


class PageModelRuntime(BaseModel):
    totalElements: Optional[int] = None
    totalPages: Optional[int] = None
    size: Optional[int] = None
    content: Optional[List[ModelRuntime]] = None
    number: Optional[int] = None
    sort: Optional[Sort] = None
    numberOfElements: Optional[int] = None
    pageable: Optional[Pageable] = None
    first: Optional[bool] = None
    last: Optional[bool] = None
    empty: Optional[bool] = None


class PageMembership(BaseModel):
    totalElements: Optional[int] = None
    totalPages: Optional[int] = None
    size: Optional[int] = None
    content: Optional[List[Membership]] = None
    number: Optional[int] = None
    sort: Optional[Sort] = None
    numberOfElements: Optional[int] = None
    pageable: Optional[Pageable] = None
    first: Optional[bool] = None
    last: Optional[bool] = None
    empty: Optional[bool] = None


class PageLabel(BaseModel):
    totalElements: Optional[int] = None
    totalPages: Optional[int] = None
    size: Optional[int] = None
    content: Optional[List[Label]] = None
    number: Optional[int] = None
    sort: Optional[Sort] = None
    numberOfElements: Optional[int] = None
    pageable: Optional[Pageable] = None
    first: Optional[bool] = None
    last: Optional[bool] = None
    empty: Optional[bool] = None


class PageExtensionPack(BaseModel):
    totalElements: Optional[int] = None
    totalPages: Optional[int] = None
    size: Optional[int] = None
    content: Optional[List[ExtensionPack]] = None
    number: Optional[int] = None
    sort: Optional[Sort] = None
    numberOfElements: Optional[int] = None
    pageable: Optional[Pageable] = None
    first: Optional[bool] = None
    last: Optional[bool] = None
    empty: Optional[bool] = None


class PageAccessToken(BaseModel):
    totalElements: Optional[int] = None
    totalPages: Optional[int] = None
    size: Optional[int] = None
    content: Optional[List[AccessToken]] = None
    number: Optional[int] = None
    sort: Optional[Sort] = None
    numberOfElements: Optional[int] = None
    pageable: Optional[Pageable] = None
    first: Optional[bool] = None
    last: Optional[bool] = None
    empty: Optional[bool] = None


class AssistantMetadata(BaseModel):
    avatar: Optional[Avatar] = None
    tags: Optional[List[str]] = None
    tabs: Optional[List[TabGroup]] = None
    options: Optional[List[Option]] = None


class Dashboard(SlugBasedMetadata):
    extensionPackRef: Optional[str] = Field(
        None,
        description='The reference to the extension pack (if the metadata object was created by an extension pack)',
    )
    rows: Optional[List[DashboardRow]] = None


class ObjectMetadata(BaseModel):
    tags: Optional[List[str]] = None
    options: Optional[List[Option]] = None


class Pipeline(SlugBasedMetadata):
    extensionPackRef: Optional[str] = Field(
        None,
        description='The reference to the extension pack (if the metadata object was created by an extension pack)',
    )
    metadata: Optional[PipelineImplementationMetadata] = None


class ProjectTaxonomy(BaseModel):
    slug: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None
    taxonomyType: Optional[TaxonomyType] = Field(
        None, description='The type of taxonomy'
    )
    taxons: Optional[List[Taxon]] = Field(
        None, description="The hierarchical structure of taxon's in this taxonomy"
    )


class ProjectTemplate(SlugBasedMetadata):
    extensionPackRef: Optional[str] = Field(
        None,
        description='The reference to the extension pack (if the metadata object was created by an extension pack)',
    )
    The_stores_that_will_be_created_with_the_project_template: Optional[
        List[ProjectStore]
    ] = Field(None, alias='The stores that will be created with the project template')
    The_assistants_that_will_be_created_with_the_project_template: Optional[
        List[ProjectAssistant]
    ] = Field(
        None, alias='The assistants that will be created with the project template'
    )
    The_taxonomies_that_will_be_created_with_the_project_template: Optional[
        List[ProjectTaxonomy]
    ] = Field(
        None, alias='The taxonomies that will be created with the project template'
    )
    The_dashboards_that_will_be_created_with_the_project_template: Optional[
        List[ProjectDashboard]
    ] = Field(
        None, alias='The dashboards that will be created with the project template'
    )
    A_help_URL_where_you_can_learn_more_about_the_assistant: Optional[str] = Field(
        None, alias='A help URL where you can learn more about the assistant'
    )
    The_category_of_project_template: Optional[TheCategoryOfProjectTemplate] = Field(
        None, alias='The category of project template'
    )


class AssistantPipeline(BaseModel):
    description: Optional[str] = None
    pipeline: Optional[Pipeline] = None
    writeBackToStore: Optional[bool] = None
    dataSourceRef: Optional[str] = None
    taxonomyRefs: Optional[List[str]] = None


class AssistantResponse(BaseModel):
    text: Optional[str] = None
    pipelines: Optional[List[AssistantPipeline]] = None


class CloudAssistant(BaseModel):
    assistantId: Optional[str] = None
    assistantName: Optional[str] = None
    ref: Optional[str] = None
    deploymentType: Optional[DeploymentType3] = None
    serviceName: Optional[str] = None
    containerName: Optional[str] = None
    options: Optional[Dict[str, Dict[str, Any]]] = None
    optionTypes: Optional[Dict[str, str]] = None
    status: Optional[Status1] = None
    exceptionDetails: Optional[ExceptionDetails] = None
    response: Optional[AssistantResponse] = None
    startDate: Optional[datetime] = None
    endDate: Optional[datetime] = None
    processingTime: Optional[int] = None


class SessionEvent(BaseModel):
    id: str
    type: Type
    executionId: Optional[str] = None
    storeRef: Optional[str] = None
    documentFamilyId: Optional[str] = None
    sessionId: str
    token: str
    subType: Optional[str] = None
    steps: Optional[List[ExecutionStep]] = None
    assistant: Optional[CloudAssistant] = None
    source: Optional[Dict[str, Dict[str, Any]]] = None
    payload: Optional[Dict[str, Dict[str, Any]]] = None
    contentObjects: Optional[List[ContentObject]] = None
    inputId: Optional[str] = None
    targetDeploymentType: Optional[TargetDeploymentType] = None
    target: Optional[str] = None
    platformUrl: Optional[str] = None
    log: Optional[List[str]] = None
    debug: Optional[bool] = None
    created: Optional[datetime] = None


class PageUser(BaseModel):
    totalElements: Optional[int] = None
    totalPages: Optional[int] = None
    size: Optional[int] = None
    content: Optional[List[User]] = None
    number: Optional[int] = None
    sort: Optional[Sort] = None
    numberOfElements: Optional[int] = None
    pageable: Optional[Pageable] = None
    first: Optional[bool] = None
    last: Optional[bool] = None
    empty: Optional[bool] = None


class PageProjectTemplate(BaseModel):
    totalElements: Optional[int] = None
    totalPages: Optional[int] = None
    size: Optional[int] = None
    content: Optional[List[ProjectTemplate]] = None
    number: Optional[int] = None
    sort: Optional[Sort] = None
    numberOfElements: Optional[int] = None
    pageable: Optional[Pageable] = None
    first: Optional[bool] = None
    last: Optional[bool] = None
    empty: Optional[bool] = None


class PagePipeline(BaseModel):
    totalElements: Optional[int] = None
    totalPages: Optional[int] = None
    size: Optional[int] = None
    content: Optional[List[Pipeline]] = None
    number: Optional[int] = None
    sort: Optional[Sort] = None
    numberOfElements: Optional[int] = None
    pageable: Optional[Pageable] = None
    first: Optional[bool] = None
    last: Optional[bool] = None
    empty: Optional[bool] = None


class PageDashboard(BaseModel):
    totalElements: Optional[int] = None
    totalPages: Optional[int] = None
    size: Optional[int] = None
    content: Optional[List[Dashboard]] = None
    number: Optional[int] = None
    sort: Optional[Sort] = None
    numberOfElements: Optional[int] = None
    pageable: Optional[Pageable] = None
    first: Optional[bool] = None
    last: Optional[bool] = None
    empty: Optional[bool] = None


class Action(SlugBasedMetadata):
    extensionPackRef: Optional[str] = Field(
        None,
        description='The reference to the extension pack (if the metadata object was created by an extension pack)',
    )
    step: Optional[StepImplementation] = None
    metadata: Optional[ObjectMetadata] = None
    readme: Optional[str] = None


class AssistantDefinition(SlugBasedMetadata):
    extensionPackRef: Optional[str] = Field(
        None,
        description='The reference to the extension pack (if the metadata object was created by an extension pack)',
    )
    The_assistant_can_be_scheduled: Optional[bool] = Field(
        None, alias='The assistant can be scheduled'
    )
    The_assistant_is_reactive_to_content_changes: Optional[bool] = Field(
        None, alias='The assistant is reactive to content changes'
    )
    The_implementation_of_the_assistant: Optional[AssistantImplementation] = Field(
        None, alias='The implementation of the assistant'
    )
    Additional_metadata_for_the_assistant: Optional[AssistantMetadata] = Field(
        None, alias='Additional metadata for the assistant'
    )
    Services_used_by_the_assistant: Optional[List[SlugBasedMetadata]] = Field(
        None, alias='Services used by the assistant'
    )
    Taxonomies_that_the_assistant_uses: Optional[List[AssistantTaxonomy]] = Field(
        None, alias='Taxonomies that the assistant uses'
    )
    Options_for_the_assistant: Optional[List[Option]] = Field(
        None, alias='Options for the assistant'
    )
    additionalTaxonOptions: Optional[List[Option]] = Field(
        None,
        description='This are additional properties that can be set on a label when the assistant is part of the project',
    )
    Event_types_that_the_assistant_is_able_to_response_to: Optional[
        List[EventType]
    ] = Field(None, alias='Event types that the assistant is able to response to')
    eventFilters: Optional[List[EventFilter]] = None
    The_default_schedules_that_the_assistant_has: Optional[
        List[ScheduleDefinition]
    ] = Field(None, alias='The default schedules that the assistant has')
    The_default_subscriptions_that_the_assistant_has: Optional[
        List[AssistantSubscription]
    ] = Field(None, alias='The default subscriptions that the assistant has')
    The_full_description_of_the_assistant: Optional[str] = Field(
        None, alias='The full description of the assistant'
    )
    A_help_URL_where_you_can_learn_more_about_the_assistant: Optional[str] = Field(
        None, alias='A help URL where you can learn more about the assistant'
    )
    The_category_of_assistant: Optional[TheCategoryOfAssistant] = Field(
        None, alias='The category of assistant'
    )


class Assistant(BaseModel):
    id: Optional[str] = Field(None, description='The unique ID of the document family')
    uuid: Optional[str] = None
    createdOn: Optional[datetime] = None
    updatedOn: Optional[datetime] = None
    schedules: Optional[List[AssistantSchedule]] = None
    name: str
    description: Optional[str] = None
    assistantDefinitionRef: Optional[str] = None
    active: Optional[bool] = None
    runOnExistingContent: Optional[bool] = None
    options: Optional[Dict[str, Dict[str, Any]]] = None
    validationErrors: Optional[List[ValidationError]] = None
    definition: Optional[AssistantDefinition] = None


class PageAssistant(BaseModel):
    totalElements: Optional[int] = None
    totalPages: Optional[int] = None
    size: Optional[int] = None
    content: Optional[List[Assistant]] = None
    number: Optional[int] = None
    sort: Optional[Sort] = None
    numberOfElements: Optional[int] = None
    pageable: Optional[Pageable] = None
    first: Optional[bool] = None
    last: Optional[bool] = None
    empty: Optional[bool] = None


class PageAssistantDefinition(BaseModel):
    totalElements: Optional[int] = None
    totalPages: Optional[int] = None
    size: Optional[int] = None
    content: Optional[List[AssistantDefinition]] = None
    number: Optional[int] = None
    sort: Optional[Sort] = None
    numberOfElements: Optional[int] = None
    pageable: Optional[Pageable] = None
    first: Optional[bool] = None
    last: Optional[bool] = None
    empty: Optional[bool] = None


class PageAction(BaseModel):
    totalElements: Optional[int] = None
    totalPages: Optional[int] = None
    size: Optional[int] = None
    content: Optional[List[Action]] = None
    number: Optional[int] = None
    sort: Optional[Sort] = None
    numberOfElements: Optional[int] = None
    pageable: Optional[Pageable] = None
    first: Optional[bool] = None
    last: Optional[bool] = None
    empty: Optional[bool] = None


class DocumentAssignment(BaseModel):
    id: Optional[str] = Field(None, description='The unique ID of the document family')
    uuid: Optional[str] = None
    createdOn: Optional[datetime] = None
    updatedOn: Optional[datetime] = None
    user: User
    documentFamily: DocumentFamily


class DocumentFamily(BaseModel):
    id: Optional[str] = Field(None, description='The unique ID of the document family')
    uuid: Optional[str] = None
    createdOn: Optional[datetime] = None
    updatedOn: Optional[datetime] = None
    documentStatus: Optional[DocumentStatus] = None
    assignments: Optional[List[DocumentAssignment]] = Field(
        None, description='A list of the assignments to users for this document'
    )
    storeRef: Optional[str] = Field(
        None,
        description='The reference to the store that is holding this document family',
    )
    path: str = Field(..., description='The path to the document family in the store')
    locked: Optional[bool] = Field(
        None,
        description='Is the document family locked. If locked then you can no longer modify or add any new document transitions',
    )
    created: Optional[datetime] = None
    modified: Optional[datetime] = None
    size: Optional[int] = None
    contentObjects: Optional[List[ContentObject]] = Field(
        None,
        description='An ordered list of the content objects in the document family',
    )
    transitions: Optional[List[DocumentTransition]] = Field(
        None, description='An ordered list of the transitions in the document family'
    )
    labels: Optional[List[Label]] = Field(
        None, description='The labels from the latest content object in the family'
    )
    mixins: Optional[List[str]] = Field(
        None, description='The mixins from the latest content object in the family'
    )
    classes: Optional[List[ContentClassification]] = Field(
        None,
        description='The classification classes from the latest content object in the family',
    )


class DataObject(BaseModel):
    id: Optional[str] = Field(None, description='The unique ID of the document family')
    uuid: Optional[str] = None
    createdOn: Optional[datetime] = None
    updatedOn: Optional[datetime] = None
    documentFamily: DocumentFamily
    taxonomyRef: Optional[str] = None
    path: Optional[str] = None
    rowNum: Optional[int] = None
    sourceOrdering: Optional[str] = None
    dateTime: Optional[datetime] = None
    lineage: Optional[DataLineage] = None
    attributes: Optional[List[DataAttribute]] = None
    parentId: Optional[str] = None
    storeRef: Optional[str] = None
    taxon: Optional[Taxon] = None


class Project(BaseModel):
    id: Optional[str] = Field(None, description='The unique ID of the document family')
    uuid: Optional[str] = None
    createdOn: Optional[datetime] = None
    updatedOn: Optional[datetime] = None
    organization: Optional[Organization] = None
    name: Optional[str] = None
    description: Optional[str] = None
    projectTemplate: Optional[ProjectTemplateMetadata] = None
    labels: Optional[List[Label]] = None
    documentStatuses: Optional[List[DocumentStatus]] = None
    attributeStatuses: Optional[List[AttributeStatus]] = None


class ProjectTemplateMetadata(BaseModel):
    id: Optional[str] = None
    uuid: Optional[str] = None
    version: Optional[str] = None
    organization: Optional[Organization] = None
    slug: str
    metadata: Optional[ProjectTemplate] = None
    extensionPackRef: Optional[str] = None
    projects: Optional[List[Project]] = None
    ref: Optional[str] = None


class SearchContent(BaseModel):
    id: Optional[str] = Field(None, description='The unique ID of the search content')
    storeRef: Optional[str] = Field(
        None, description='The ref of the store containing the document family'
    )
    documentFamilyId: Optional[str] = Field(
        None, description='The unique ID of the document family'
    )
    containerType: Optional[str] = Field(None, description='The container node type')
    containerUuid: Optional[str] = Field(None, description='The container node UUID')
    sourceOrdering: Optional[int] = Field(
        None, description='The source ordering for the content (starting at 0)'
    )
    entities: Optional[List[SearchEntity]] = Field(
        None, description='Entities found in the search content'
    )
    nodeUuid: Optional[str] = Field(
        None, description='The unique ID of the content node'
    )
    content: Optional[str] = Field(None, description='The indexed content')
    documentFamily: Optional[DocumentFamily] = None


class Execution(BaseModel):
    id: Optional[str] = Field(None, description='The unique ID of the document family')
    uuid: Optional[str] = None
    createdOn: Optional[datetime] = None
    updatedOn: Optional[datetime] = None
    orgSlug: Optional[str] = None
    assistant: Optional[Assistant] = None
    description: Optional[str] = None
    targets: Optional[List[ExecutionTarget]] = None
    session: Optional[Session] = None
    startDate: Optional[datetime] = None
    endDate: Optional[datetime] = None
    processingTime: Optional[int] = None
    status: Optional[Status3] = None
    exceptionDetails: Optional[ExceptionDetails] = None
    steps: Optional[List[ExecutionStep]] = None
    parameters: Optional[Dict[str, Dict[str, Any]]] = None
    customOptions: Optional[Dict[str, Dict[str, Any]]] = None
    context: Optional[Dict[str, Dict[str, Any]]] = None
    childExecutions: Optional[List[Execution]] = None
    stores: Optional[List[SessionStore]] = None
    inputId: Optional[str] = None
    outputId: Optional[str] = None
    documentFamily: Optional[DocumentFamily] = None
    numberOfSteps: Optional[int] = None
    stepsCompleted: Optional[int] = None
    statusText: Optional[str] = None
    statusFull: Optional[str] = None


class ExecutionEvent(BaseModel):
    execution: Optional[Execution] = None
    event: Optional[SessionEvent] = None


class PageDocumentFamily(BaseModel):
    totalElements: Optional[int] = None
    totalPages: Optional[int] = None
    size: Optional[int] = None
    content: Optional[List[DocumentFamily]] = None
    number: Optional[int] = None
    sort: Optional[Sort] = None
    numberOfElements: Optional[int] = None
    pageable: Optional[Pageable] = None
    first: Optional[bool] = None
    last: Optional[bool] = None
    empty: Optional[bool] = None


class PlatformEvent(BaseModel):
    id: Optional[str] = Field(None, description='The unique ID of the document family')
    uuid: Optional[str] = None
    createdOn: Optional[datetime] = None
    updatedOn: Optional[datetime] = None
    organization: Optional[Organization] = None
    eventType: Optional[str] = None
    session: Optional[Session] = None
    execution: Optional[Execution] = None
    assistant: Optional[Assistant] = None
    description: Optional[str] = None
    dateTime: Optional[datetime] = None
    status: Optional[Status4] = None
    exceptionDetail: Optional[ExceptionDetails] = None
    processingTime: Optional[int] = None
    documentFamily: Optional[DocumentFamily] = None


class PageDataObject(BaseModel):
    totalElements: Optional[int] = None
    totalPages: Optional[int] = None
    size: Optional[int] = None
    content: Optional[List[DataObject]] = None
    number: Optional[int] = None
    sort: Optional[Sort] = None
    numberOfElements: Optional[int] = None
    pageable: Optional[Pageable] = None
    first: Optional[bool] = None
    last: Optional[bool] = None
    empty: Optional[bool] = None


class PageExecution(BaseModel):
    totalElements: Optional[int] = None
    totalPages: Optional[int] = None
    size: Optional[int] = None
    content: Optional[List[Execution]] = None
    number: Optional[int] = None
    sort: Optional[Sort] = None
    numberOfElements: Optional[int] = None
    pageable: Optional[Pageable] = None
    first: Optional[bool] = None
    last: Optional[bool] = None
    empty: Optional[bool] = None


class PageProject(BaseModel):
    totalElements: Optional[int] = None
    totalPages: Optional[int] = None
    size: Optional[int] = None
    content: Optional[List[Project]] = None
    number: Optional[int] = None
    sort: Optional[Sort] = None
    numberOfElements: Optional[int] = None
    pageable: Optional[Pageable] = None
    first: Optional[bool] = None
    last: Optional[bool] = None
    empty: Optional[bool] = None


class PagePlatformEvent(BaseModel):
    totalElements: Optional[int] = None
    totalPages: Optional[int] = None
    size: Optional[int] = None
    content: Optional[List[PlatformEvent]] = None
    number: Optional[int] = None
    sort: Optional[Sort] = None
    numberOfElements: Optional[int] = None
    pageable: Optional[Pageable] = None
    first: Optional[bool] = None
    last: Optional[bool] = None
    empty: Optional[bool] = None


Taxon.update_forward_refs()
DocumentAssignment.update_forward_refs()
Project.update_forward_refs()
